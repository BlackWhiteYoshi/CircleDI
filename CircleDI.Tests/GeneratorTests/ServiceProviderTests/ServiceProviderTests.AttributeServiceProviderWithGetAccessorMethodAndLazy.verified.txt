// <auto-generated/>
#pragma warning disable
#nullable enable annotations


using System;
using System.Threading.Tasks;

namespace MyCode;

/// <summary>
/// <para>
/// Number of services registered: 5<br />
/// - Singleton: 2<br />
/// - Scoped: 2<br />
/// - Transient: 1<br />
/// - Delegate: 0
/// </para>
/// <para>
/// This provider can create a scope,<br />
/// implements both Dispose() and DisposeAsync() methods<br />
/// and is thread safe.
/// </para>
/// </summary>
public sealed partial class TestProvider : global::MyCode.ITestProvider, IServiceProvider {
    /// <summary>
    /// Creates an instance of <see cref="global::MyCode.TestProvider"/> together with all <see cref="global::CircleDIAttributes.CreationTiming.Constructor">non-lazy</see> singleton services.
    /// </summary>
    public TestProvider() {
    }

    /// <summary>
    /// Creates an instance of <see cref="global::MyCode.TestProvider.Scope"/> together with all <see cref="global::CircleDIAttributes.CreationTiming.Constructor">non-lazy</see> scoped services.
    /// </summary>
    public global::MyCode.ITestProvider.IScope CreateScope() => new global::MyCode.TestProvider.Scope(GetSelf());


    /// <summary>
    /// Lifetime: <see cref="global::CircleDIAttributes.SingletonAttribute{TService}">Singleton</see><br />
    /// Service type: <see cref="global::MyCode.ISingleton"/><br />
    /// Implementation type:  <see cref="global::MyCode.Singleton"/>
    /// </summary>
    public global::MyCode.ISingleton GetSingleton() {
        if (_singleton == null)
            lock (this)
                if (_singleton == null) {
                    _singleton = new global::MyCode.Singleton();
                }

        return (global::MyCode.ISingleton)_singleton;
    }
    private global::MyCode.Singleton? _singleton;

    /// <summary>
    /// Lifetime: <see cref="global::CircleDIAttributes.SingletonAttribute{TService}">Singleton</see><br />
    /// Service type: <see cref="global::MyCode.ITestProvider"/><br />
    /// Implementation type:  <see cref="global::MyCode.TestProvider"/>
    /// </summary>
    public global::MyCode.ITestProvider GetSelf() => this;


    /// <summary>
    /// Lifetime: <see cref="global::CircleDIAttributes.TransientAttribute{TService}">Transient</see><br />
    /// Service type: <see cref="global::MyCode.ITransient"/><br />
    /// Implementation type:  <see cref="global::MyCode.Transient"/>
    /// </summary>
    public global::MyCode.ITransient GetTransient() => new global::MyCode.Transient();


    /// <summary>
    /// <para>Finds all registered services of the given type.</para>
    /// <para>
    /// The method returns<br />
    /// - null (when registered zero times)<br />
    /// - given type (when registered ones)<br />
    /// - Array of given type (when registered many times)
    /// </para>
    /// </summary>
    object? IServiceProvider.GetService(Type serviceType) {
        if (serviceType == typeof(global::MyCode.ISingleton))
            return GetSingleton();
        if (serviceType == typeof(global::MyCode.ITestProvider))
            return GetSelf();
        if (serviceType == typeof(global::MyCode.ITransient))
            return GetTransient();
        return null;
    }


    /// <summary>
    /// Disposes all disposable services instantiated by this provider.
    /// </summary>
    public void Dispose() {
    }

    /// <summary>
    /// Disposes all disposable services instantiated by this provider asynchronously.
    /// </summary>
    public ValueTask DisposeAsync() {
        return default;
    }



    /// <summary>
    /// <para>
    /// Number of services registered: 5<br />
    /// - Singleton: 2<br />
    /// - Scoped: 2<br />
    /// - Transient: 1<br />
    /// - Delegate: 0
    /// </para>
    /// <para>
    /// This provider can create a scope,<br />
    /// implements both Dispose() and DisposeAsync() methods<br />
    /// and is thread safe.
    /// </para>
    /// </summary>
    public sealed partial class Scope : global::MyCode.ITestProvider.IScope, IServiceProvider {
        private global::MyCode.ITestProvider __serviceProvider;

        /// <summary>
        /// Creates an instance of <see cref="global::MyCode.TestProvider.Scope"/> together with all <see cref="global::CircleDIAttributes.CreationTiming.Constructor">non-lazy</see> scoped services.
        /// </summary>
        /// <param name="serviceProvider">An instance of the service provider this provider is the scope of.</param>
        public Scope(global::MyCode.ITestProvider serviceProvider) {
            __serviceProvider = serviceProvider;
        }

        /// <summary>
        /// Lifetime: <see cref="global::CircleDIAttributes.ScopedAttribute{TService}">Scoped</see><br />
        /// Service type: <see cref="global::MyCode.IScoped"/><br />
        /// Implementation type:  <see cref="global::MyCode.Scoped"/>
        /// </summary>
        public global::MyCode.IScoped GetScoped() {
            if (_scoped == null)
                lock (this)
                    if (_scoped == null) {
                        _scoped = new global::MyCode.Scoped();
                    }

            return (global::MyCode.IScoped)_scoped;
        }
        private global::MyCode.Scoped? _scoped;

        /// <summary>
        /// Lifetime: <see cref="global::CircleDIAttributes.ScopedAttribute{TService}">Scoped</see><br />
        /// Service type: <see cref="global::MyCode.ITestProvider.IScope"/><br />
        /// Implementation type:  <see cref="global::MyCode.TestProvider.Scope"/>
        /// </summary>
        public global::MyCode.ITestProvider.IScope GetSelfScope() => this;


        /// <summary>
        /// Lifetime: <see cref="global::CircleDIAttributes.SingletonAttribute{TService}">Singleton</see><br />
        /// Service type: <see cref="global::MyCode.ISingleton"/><br />
        /// Implementation type:  <see cref="global::MyCode.Singleton"/>
        /// </summary>
        public global::MyCode.ISingleton GetSingleton() => __serviceProvider.GetSingleton();

        /// <summary>
        /// Lifetime: <see cref="global::CircleDIAttributes.SingletonAttribute{TService}">Singleton</see><br />
        /// Service type: <see cref="global::MyCode.ITestProvider"/><br />
        /// Implementation type:  <see cref="global::MyCode.TestProvider"/>
        /// </summary>
        public global::MyCode.ITestProvider GetSelf() => __serviceProvider.GetSelf();


        /// <summary>
        /// Lifetime: <see cref="global::CircleDIAttributes.TransientAttribute{TService}">Transient</see><br />
        /// Service type: <see cref="global::MyCode.ITransient"/><br />
        /// Implementation type:  <see cref="global::MyCode.Transient"/>
        /// </summary>
        public global::MyCode.ITransient GetTransient() => new global::MyCode.Transient();


        /// <summary>
        /// <para>Finds all registered services of the given type.</para>
        /// <para>
        /// The method returns<br />
        /// - null (when registered zero times)<br />
        /// - given type (when registered ones)<br />
        /// - Array of given type (when registered many times)
        /// </para>
        /// </summary>
        object? IServiceProvider.GetService(Type serviceType) {
            if (serviceType == typeof(global::MyCode.IScoped))
                return GetScoped();
            if (serviceType == typeof(global::MyCode.ISingleton))
                return GetSingleton();
            if (serviceType == typeof(global::MyCode.ITestProvider))
                return GetSelf();
            if (serviceType == typeof(global::MyCode.ITestProvider.IScope))
                return GetSelfScope();
            if (serviceType == typeof(global::MyCode.ITransient))
                return GetTransient();
            return null;
        }


        /// <summary>
        /// Disposes all disposable services instantiated by this provider.
        /// </summary>
        public void Dispose() {
        }

        /// <summary>
        /// Disposes all disposable services instantiated by this provider asynchronously.
        /// </summary>
        public ValueTask DisposeAsync() {
            return default;
        }
    }
}

namespace CircleDI.Defenitions;

public static partial class Attributes {
    public const string ServiceProviderAttribute = $$"""
        // <auto-generated/>
        #pragma warning disable
        #nullable enable annotations


        #if !CIRCLEDI_EXCLUDE_ATTRIBUTES
        
        using System;
    
        namespace CircleDIAttributes;
        
        {{ServiceProviderAttributeSummary}}
        [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("{{NAME}}", "{{VERSION}}")]
        internal sealed class ServiceProviderAttribute : Attribute {
            /// <summary>
            /// <para>Name/Identifier of the generated Interface.</para>
            /// <para>If omitted, the name will be "I{ClassName}".</para>
            /// </summary>
            public string InterfaceName { get; init; }

            {{ServiceProviderAttributeContentWithoutInterfaceName}}
        }

        {{ServiceProviderAttributeSummary}}
        /// <typeparam name="TInterface">
        /// An explicit declared interface the generated interface will be based on: The name, access modifier, namespace and containing types will be inferred.<br />
        /// That interface must be partial.<br />
        /// If the generated interface is used without declaring the interface yourself, it will have no effect.
        /// </typeparam>
        [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]
        [System.CodeDom.Compiler.GeneratedCodeAttribute("{{NAME}}", "{{VERSION}}")]
        internal sealed class ServiceProviderAttribute<TInterface> : Attribute {
            {{ServiceProviderAttributeContentWithoutInterfaceName}}
        }

        #endif

        """;


    private const string ServiceProviderAttributeSummary = """
        /// <summary>
        /// <para>A class decorated with this attribute becomes a service provider. That class must be partial.</para>
        /// <para>
        /// To add services to that class, add additional attributes to that class:<br />
        /// <see cref="SingletonAttribute{TService, TImplementation}" />, <see cref="ScopedAttribute{TService, TImplementation}" />, <see cref="TransientAttribute{TService, TImplementation}" />, <see cref="DelegateAttribute{TService}" />.
        /// </para>
        /// <para>The source generator will generate a complete service provider, but you can add additional custom implementation to it.</para>
        /// </summary>
        """;

    private const string ServiceProviderAttributeContentWithoutInterfaceName = """
        /// <summary>
            /// <para>
            /// Decides whether services defaulting to lazy construction or instantiation inside the constructor.
            /// This option applies to all services where the "CreationTime"-attribute is not set.
            /// </para>
            /// <para>Default is <see cref="CreationTiming.Constructor" />.</para>
            /// </summary>
            public CreationTiming CreationTime { get; init; }

            /// <summary>
            /// <para>
            /// Decides whether the members to access the services in the ServiceProvider defaulting to properties or methods.
            /// This option applies to all services where the "GetAccessor"-attribute is not set.
            /// </para>
            /// <para>Default is <see cref="GetAccess.Property" />.</para>
            /// </summary>
            public GetAccess GetAccessor { get; init; }

            /// <summary>
            /// <para>Toggles the generation of the Dispose methods:</para>
            /// <para>
            /// public void Dispose();<br />
            /// public ValueTask DisposeAsync();
            /// </para>
            /// <para>It can be toggled that both are generated, only one of them or the generation is skipped entirely.</para>
            /// <para>Default is <see cref="DisposeGeneration.GenerateBoth" />.</para>
            /// </summary>
            public DisposeGeneration GenerateDisposeMethods { get; init; }

            /// <summary>
            /// <para>Indicates if the generated code will be thread safe or a little bit more efficient.</para>
            /// <para>
            /// Affects performance for lazy constructed singleton services and disposables transient services:<br />
            /// - Singletons acquire a lock for construction.<br />
            /// - Disposable transient services acquire a lock when constructed and disposed to synchronize access on a dispose-list.
            /// </para>
            /// <para>This option should be set to false, if the provider is used in a single threaded scenario or only accessed by one thread at a time.</para>
            /// <para>Default is true.</para>
            /// </summary>
            public bool ThreadSafe { get; init; }
        """;
}

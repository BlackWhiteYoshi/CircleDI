using CircleDI.Defenitions;
using CircleDI.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.Extensions.ObjectPool;
using System.Text;

namespace CircleDI.Generation;

/// <summary>
/// Contains the build functionality to build the ServiceProvider/ScopeProvider class and interface.
/// </summary>
public static class CircleDIBuilder {
    /// <summary>
    /// Gives a preconfigured <see cref="ObjectPool<StringBuilder>"/> for building class or interface.
    /// </summary>
    /// <returns></returns>
    public static ObjectPool<StringBuilder> CreateStringBuilderPool() => new DefaultObjectPoolProvider().CreateStringBuilderPool(initialCapacity: 8192, maximumRetainedCapacity: 1024 * 1024);


    /// <summary>
    /// Builds the ServiceProvider class with ScopeProvider class.
    /// </summary>
    /// <param name="stringBuilderPool"></param>
    /// <param name="context"></param>
    /// <param name="serviceProvider"></param>
    public static void GenerateClass(this ObjectPool<StringBuilder> stringBuilderPool, SourceProductionContext context, ServiceProvider serviceProvider) {
        if (serviceProvider.ErrorList.Count > 0) {
            foreach (Diagnostic error in serviceProvider.ErrorList)
                context.ReportDiagnostic(error);

            return;
        }

        StringBuilder builder = stringBuilderPool.Get();
        CircleDIBuilderCore core = new(builder, serviceProvider);

        builder.Append("""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable annotations


            using System;

            """);
        if (serviceProvider.GenerateDisposeMethods.HasFlag(DisposeGeneration.DisposeAsync) || serviceProvider.GenerateDisposeMethodsScope.HasFlag(DisposeGeneration.DisposeAsync))
            builder.Append("using System.Threading.Tasks;\n");
        builder.Append('\n');

        builder.AppendNamespace(serviceProvider.Identifier.NameSpaceList);

        // containing types
        for (int i = serviceProvider.Identifier.ContainingTypeList.Count - 1; i >= 0; i--) {
            builder.AppendIndent(core.indent);
            builder.Append("partial ");
            builder.Append(serviceProvider.Identifier.ContainingTypeList[i].Keyword.AsString());
            builder.Append(' ');
            builder.AppendOpenContainingType(serviceProvider.Identifier.ContainingTypeList[i]);
            builder.Append(" {\n");
            core.indent.IncreaseLevel();
        }

        // class head
        core.AppendClassSummary();
        builder.AppendIndent(core.indent);
        foreach (string modifier in serviceProvider.Modifiers) {
            builder.Append(modifier);
            builder.Append(' ');
        }
        builder.Append("partial ");
        builder.Append(serviceProvider.Keyword.AsString());
        builder.Append(' ');
        builder.Append(serviceProvider.Identifier.Name);
        builder.AppendOpenGenerics(serviceProvider.Identifier);
        builder.Append(" : ");
        if (serviceProvider.HasInterface) {
            builder.Append("global::");
            builder.AppendOpenFullyQualified(serviceProvider.InterfaceIdentifier);
            builder.Append(", ");
        }
        builder.Append("IServiceProvider {\n");

        // parameter fields, constructor or InitServices()
        core.AppendConstructor();

        // "special" method CreateScope()
        core.AppendCreateScope();

        // singletons getter/getMethods
        core.AppendServicesGetter();

        // Transient services
        core.AppendServicesTransient();

        // Delegate services
        core.AppendServicesDelegate();

        // IServiceProvider
        core.AppendIServiceProviderNotScoped();

        // Dispose
        core.AppendDisposeMethods();


        // Scope
        if (serviceProvider.GenerateScope) {
            core.SetToScope();
            builder.Append('\n');

            // class head
            core.AppendClassSummary();
            builder.AppendIndent(core.indent);
            foreach (string modifier in serviceProvider.ModifiersScope) {
                builder.Append(modifier);
                builder.Append(' ');
            }
            builder.Append("partial ");
            builder.Append(serviceProvider.KeywordScope.AsString());
            builder.Append(" Scope");
            builder.AppendOpenGenerics(serviceProvider.IdentifierScope);
            builder.Append(" : ");
            if (serviceProvider.HasInterface) {
                builder.Append("global::");
                builder.AppendOpenFullyQualified(serviceProvider.InterfaceIdentifierScope);
                builder.Append(", ");
            }
            builder.Append("IServiceProvider {\n");

            // parameter fields, constructor or InitServices()
            core.AppendConstructor();


            // scoped getter/getMethods
            core.AppendServicesGetter();

            // singleton exposing
            foreach (Service service in serviceProvider.SingletonList) {
                string refOrEmpty = (service.IsRefable && !serviceProvider.KeywordScope.HasFlag(TypeKeyword.Struct) && !serviceProvider.Keyword.HasFlag(TypeKeyword.Struct)) switch {
                    true => "ref ",
                    false => string.Empty
                };

                core.AppendServiceSummary(service);
                builder.AppendIndent(core.indent, 1);
                builder.Append("public ");
                builder.Append(refOrEmpty);
                builder.Append("global::");
                builder.AppendClosedFullyQualified(service.ServiceType);
                builder.Append(' ');
                builder.AppendServiceGetter(service);
                builder.Append(" => ");
                builder.Append(refOrEmpty);
                core.AppendServiceProviderField();
                builder.AppendServiceGetter(service);
                builder.Append(";\n\n");
            }
            builder.Append('\n');

            // Transient services
            core.AppendServicesTransient();

            // Delegate services
            core.AppendServicesDelegate();

            // IServiceProvider
            core.AppendIServiceProviderAllServices();

            // Dispose
            core.AppendDisposeMethods();

            // ScopedProvider closing
            builder.Length -= 2;
            builder.AppendIndent(core.indent);
            builder.Append("}\n");

            core.indent.DecreaseLevel();
        }
        else
            builder.Length -= 2;

        
        // UnsafeAccessor methods to access init-only circle dependencies
        builder.Append("\n\n\n");
        int currentPosition = builder.Length;

        foreach (Service service in serviceProvider.SortedServiceList)
            foreach (PropertyDependency dependency in service.PropertyDependencyList)
                if (dependency.IsCircular && dependency.IsInit) {
                    builder.AppendIndent(core.indent, 1);
                    builder.Append("[System.Runtime.CompilerServices.UnsafeAccessor(System.Runtime.CompilerServices.UnsafeAccessorKind.Method, Name = \"set_");
                    builder.Append(dependency.Name);
                    builder.Append("\")]\n");

                    builder.AppendIndent(core.indent, 1);
                    builder.Append("private extern static void Set_");
                    builder.Append(service.Name);
                    builder.Append('_');
                    builder.Append(dependency.Name);
                    builder.Append("(global::");
                    builder.AppendClosedFullyQualified(dependency.ImplementationBaseName);
                    builder.Append(" instance, global::");
                    builder.AppendClosedFullyQualified(dependency.Service!.ServiceType);
                    builder.Append(" value);\n\n");
                }

        if (builder.Length == currentPosition)
            builder.Length -= 3;
        else
            builder.Length--;


        // ServiceProvider closing
        builder.AppendIndent(core.indent);
        builder.Append("}\n");

        // containing types closing
        for (int i = 0; i < serviceProvider.Identifier.ContainingTypeList.Count; i++) {
            core.indent.DecreaseLevel();
            builder.AppendIndent(core.indent);
            builder.Append("}\n");
        }

        string source = builder.ToString();
        string hintName = builder.CreateHintName(serviceProvider.Identifier, ".g.cs");
        context.AddSource(hintName, source);

        stringBuilderPool.Return(builder);
    }

    /// <summary>
    /// Builds the ServiceProvider interface with ScopeProvider interface.
    /// </summary>
    /// <param name="stringBuilderPool"></param>
    /// <param name="context"></param>
    /// <param name="serviceProvider"></param>
    /// <exception cref="Exception"></exception>
    public static void GenerateInterface(this ObjectPool<StringBuilder> stringBuilderPool, SourceProductionContext context, ServiceProvider serviceProvider) {
        if (!serviceProvider.HasInterface || serviceProvider.ErrorList.Count > 0)
            return;

        StringBuilder builder = stringBuilderPool.Get();
        CircleDIBuilderCore core = new(builder, serviceProvider);

        builder.Append("""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable annotations


            using System;
    
            
            """);
        builder.AppendNamespace(serviceProvider.InterfaceIdentifier.NameSpaceList);

        // containing types
        for (int i = serviceProvider.InterfaceIdentifier.ContainingTypeList.Count - 1; i >= 0; i--) {
            builder.AppendIndent(core.indent);
            builder.Append("partial ");
            builder.Append(serviceProvider.InterfaceIdentifier.ContainingTypeList[i].Keyword.AsString());
            builder.Append(' ');
            builder.AppendOpenContainingType(serviceProvider.InterfaceIdentifier.ContainingTypeList[i]);
            builder.Append(" {\n");
            core.indent.IncreaseLevel();
        }

        // interface head
        core.AppendClassSummary();
        builder.AppendIndent(core.indent);
        builder.Append(serviceProvider.InterfaceAccessibility.AsString());
        builder.Append("partial interface ");
        builder.Append(serviceProvider.InterfaceIdentifier.Name);
        builder.AppendOpenGenerics(serviceProvider.InterfaceIdentifier);
        builder.Append(serviceProvider.GenerateDisposeMethods switch {
            DisposeGeneration.NoDisposing => string.Empty,
            DisposeGeneration.Dispose => " : IDisposable",
            DisposeGeneration.DisposeAsync => " : IAsyncDisposable",
            DisposeGeneration.GenerateBoth => " : IDisposable, IAsyncDisposable",
            _ => throw new Exception($"Invalid DisposeGenerationEnum value: serviceProvider.GenerateDisposeMethods = {serviceProvider.GenerateDisposeMethods}")
        });
        builder.Append(" {\n");

        // "special" method CreateScope()
        if (serviceProvider.GenerateScope) {
            core.AppendCreateScopeSummary();
            builder.AppendIndent(core.indent, 1);
            builder.Append("global::");
            builder.AppendOpenFullyQualified(serviceProvider.InterfaceIdentifierScope);
            builder.Append(" CreateScope");
            builder.AppendOpenGenerics(serviceProvider.IdentifierScope);
            builder.Append('(');
            foreach (Dependency dependency in serviceProvider.CreateScope.ConstructorDependencyList.Concat<Dependency>(serviceProvider.CreateScope.PropertyDependencyList))
                if (!dependency.HasAttribute) {
                    // if no attribute => dependency.ServiceType has value
                    builder.Append("global::");
                    builder.AppendClosedFullyQualified(dependency.ServiceType!);
                    builder.Append(' ');
                    builder.Append(dependency.Name);
                    builder.Append(", ");
                }
            if (builder[^1] == ' ')
                builder.Length -= 2;
            builder.Append(");\n\n");
        }

        // service getter
        foreach (Service service in serviceProvider.SortedServiceList) {
            if (service.Lifetime.HasFlag(ServiceLifetime.Scoped))
                continue;
            if (service.Implementation.Type != MemberType.None && service.Implementation.IsScoped)
                continue;

            core.AppendServiceSummary(service);
            builder.AppendIndent(core.indent, 1);

            if (service.IsRefable && !serviceProvider.Keyword.HasFlag(TypeKeyword.Struct))
                builder.Append("ref ");

            builder.Append("global::");
            builder.AppendClosedFullyQualified(service.ServiceType);
            builder.Append(' ');
            if (service.GetAccessor == GetAccess.Property) {
                builder.Append(service.Name);
                builder.Append(" { get; }");
            }
            else {
                builder.Append("Get");
                builder.Append(service.Name);
                builder.Append("();");
            }
            builder.Append("\n\n");
        }

        // IScope
        if (serviceProvider.GenerateScope) {
            core.SetToScope();
            builder.Append('\n');

            // class head
            core.AppendClassSummary();
            builder.AppendIndent(core.indent);
            builder.Append(serviceProvider.InterfaceAccessibilityScope.AsString());
            builder.Append("partial interface IScope");
            builder.AppendOpenGenerics(serviceProvider.InterfaceIdentifierScope);
            builder.Append(serviceProvider.GenerateDisposeMethodsScope switch {
                DisposeGeneration.NoDisposing => string.Empty,
                DisposeGeneration.Dispose => " : IDisposable",
                DisposeGeneration.DisposeAsync => " : IAsyncDisposable",
                DisposeGeneration.GenerateBoth => " : IDisposable, IAsyncDisposable",
                _ => throw new Exception($"Invalid DisposeGenerationEnum value: serviceProvider.GenerateDisposeMethodsScope = {serviceProvider.GenerateDisposeMethodsScope}")
            });
            builder.Append(" {\n");

            // service getter
            foreach (Service service in serviceProvider.SortedServiceList) {
                core.AppendServiceSummary(service);
                builder.AppendIndent(core.indent, 1);

                bool isSingletonNotRefable = service.Lifetime == ServiceLifetime.Singleton && serviceProvider.Keyword.HasFlag(TypeKeyword.Struct);
                if (service.IsRefable && !serviceProvider.KeywordScope.HasFlag(TypeKeyword.Struct) && !isSingletonNotRefable)
                    builder.Append("ref ");

                builder.Append("global::");
                builder.AppendClosedFullyQualified(service.ServiceType);
                builder.Append(' ');
                if (service.GetAccessor == GetAccess.Property) {
                    builder.Append(service.Name);
                    builder.Append(" { get; }");
                }
                else {
                    builder.Append("Get");
                    builder.Append(service.Name);
                    builder.Append("();");
                }
                builder.Append("\n\n");
            }

            builder.Length--;
            builder.AppendIndent(core.indent);
            builder.Append("}\n");

            core.indent.DecreaseLevel();
        }
        else
            builder.Length--;

        builder.AppendIndent(core.indent);
        builder.Append("}\n");

        // containing types closing
        for (int i = 0; i < serviceProvider.InterfaceIdentifier.ContainingTypeList.Count; i++) {
            core.indent.DecreaseLevel();
            builder.AppendIndent(core.indent);
            builder.Append("}\n");
        }

        string source = builder.ToString();
        string hintName = builder.CreateHintName(serviceProvider.InterfaceIdentifier, ".g.cs");
        context.AddSource(hintName, source);

        stringBuilderPool.Return(builder);
    }
}

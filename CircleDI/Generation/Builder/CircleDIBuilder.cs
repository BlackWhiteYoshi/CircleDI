using CircleDI.Defenitions;
using CircleDI.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.Extensions.ObjectPool;
using System.Text;

namespace CircleDI.Generation;

/// <summary>
/// Contains the build functionality to build the ServiceProvider/ScopeProvider class and interface.
/// </summary>
public static class CircleDIBuilder {
    /// <summary>
    /// Gives a preconfigured <see cref="ObjectPool{StringBuilder}"/> for building class or interface.
    /// </summary>
    /// <returns></returns>
    public static ObjectPool<StringBuilder> CreateStringBuilderPool() => new DefaultObjectPoolProvider().CreateStringBuilderPool(initialCapacity: 8192, maximumRetainedCapacity: 1024 * 1024);


    /// <summary>
    /// Builds the ServiceProvider class with ScopeProvider class.
    /// </summary>
    /// <param name="stringBuilderPool"></param>
    /// <param name="context"></param>
    /// <param name="serviceProvider"></param>
    public static void GenerateClass(this ObjectPool<StringBuilder> stringBuilderPool, SourceProductionContext context, ServiceProvider serviceProvider) {
        if (serviceProvider.ErrorManager.ErrorList.Count > 0) {
            foreach (Diagnostic error in serviceProvider.ErrorManager.ErrorList)
                context.ReportDiagnostic(error);

            return;
        }

        StringBuilder builder = stringBuilderPool.Get();
        CircleDIBuilderCore core = new(builder, serviceProvider);

        builder.AppendInterpolation($"""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable annotations


            using System;
            {(serviceProvider.GenerateDisposeMethods.HasFlag(DisposeGeneration.DisposeAsync) || serviceProvider.GenerateDisposeMethodsScope.HasFlag(DisposeGeneration.DisposeAsync)
                ? "using System.Threading.Tasks;\n" : "")}
            {serviceProvider.Identifier.NameSpaceList.AsNamespace()}
            """);

        // containing types
        for (int i = serviceProvider.Identifier.ContainingTypeList.Count - 1; i >= 0; i--) {
            builder.AppendInterpolation($"{core.indent}partial {serviceProvider.Identifier.ContainingTypeList[i].Keyword.AsString()} {serviceProvider.Identifier.ContainingTypeList[i].AsOpenName()} {{\n");
            core.indent.IncreaseLevel();
        }

        // class head
        core.AppendClassSummary();
        builder.AppendInterpolation($"{core.indent}{serviceProvider.Modifiers.AsStringJoin(" ")} partial {serviceProvider.Keyword.AsString()} {serviceProvider.Identifier.AsOpenName()} : ");
        if (serviceProvider.HasInterface)
            builder.AppendInterpolation($"global::{serviceProvider.InterfaceIdentifier.AsOpenFullyQualified()}, ");
        builder.Append("IServiceProvider {\n");
        core.indent.IncreaseLevel(); // 1

        core.AppendConstructor();
        core.AppendCreateScope();
        core.AppendSingletonScopedServices();
        core.AppendTransientServices();
        core.AppendDelegateServices();
        core.AppendIServiceProviderNotScoped();
        core.AppendDisposeMethods();


        // Scope
        if (serviceProvider.GenerateScope) {
            core.SetToScope();
            builder.Append('\n');

            // class head
            core.AppendClassSummary();
            builder.AppendInterpolation($"{core.indent}{serviceProvider.ModifiersScope.AsStringJoin(" ")} partial {serviceProvider.KeywordScope.AsString()} Scope{serviceProvider.IdentifierScope.AsOpenGenerics()} : ");
            if (serviceProvider.HasInterface)
                builder.AppendInterpolation($"global::{serviceProvider.InterfaceIdentifierScope.AsOpenFullyQualified()}, ");
            builder.Append("IServiceProvider {\n");
            core.indent.IncreaseLevel(); // 2

            core.AppendConstructor();
            core.AppendSingletonScopedServices();
            core.AppendSingletonExposing();
            core.AppendTransientServices();
            core.AppendDelegateServices();
            core.AppendIServiceProviderAllServices();
            core.AppendDisposeMethods();

            // ScopedProvider closing
            builder.Length -= 2;
            core.indent.DecreaseLevel(); // 1
            builder.AppendInterpolation($"{core.indent}}}\n");
        }
        else
            builder.Length -= 2;

        core.AppendUnsafeAccessorMethods();

        // ServiceProvider closing
        core.indent.DecreaseLevel(); // 0
        builder.AppendInterpolation($"{core.indent}}}\n");

        // containing types closing
        for (int i = 0; i < serviceProvider.Identifier.ContainingTypeList.Count; i++) {
            core.indent.DecreaseLevel();
            builder.AppendInterpolation($"{core.indent}}}\n");
        }

        string source = builder.ToString();
        string hintName = builder.CreateHintName(serviceProvider.Identifier, ".g.cs");
        context.AddSource(hintName, source);

        stringBuilderPool.Return(builder);
    }

    /// <summary>
    /// Builds the ServiceProvider interface with ScopeProvider interface.
    /// </summary>
    /// <param name="stringBuilderPool"></param>
    /// <param name="context"></param>
    /// <param name="serviceProvider"></param>
    /// <exception cref="Exception"></exception>
    public static void GenerateInterface(this ObjectPool<StringBuilder> stringBuilderPool, SourceProductionContext context, ServiceProvider serviceProvider) {
        if (!serviceProvider.HasInterface || serviceProvider.ErrorManager.ErrorList.Count > 0)
            return;

        StringBuilder builder = stringBuilderPool.Get();
        CircleDIBuilderCore core = new(builder, serviceProvider);

        builder.AppendInterpolation($"""
            // <auto-generated/>
            #pragma warning disable
            #nullable enable annotations


            using System;

            {serviceProvider.InterfaceIdentifier.NameSpaceList.AsNamespace()}
            """);

        // containing types
        for (int i = serviceProvider.InterfaceIdentifier.ContainingTypeList.Count - 1; i >= 0; i--) {
            builder.AppendInterpolation($"{core.indent}partial {serviceProvider.InterfaceIdentifier.ContainingTypeList[i].Keyword.AsString()} {serviceProvider.InterfaceIdentifier.ContainingTypeList[i].AsOpenName()} {{\n");
            core.indent.IncreaseLevel();
        }

        // interface head
        core.AppendClassSummary();
        string disposeInterfaces = serviceProvider.GenerateDisposeMethods switch {
            DisposeGeneration.NoDisposing => string.Empty,
            DisposeGeneration.Dispose => " : IDisposable",
            DisposeGeneration.DisposeAsync => " : IAsyncDisposable",
            DisposeGeneration.GenerateBoth => " : IDisposable, IAsyncDisposable",
            _ => throw new Exception($"Invalid DisposeGenerationEnum value: serviceProvider.GenerateDisposeMethods = {serviceProvider.GenerateDisposeMethods}")
        };
        builder.AppendInterpolation($"{core.indent}{serviceProvider.InterfaceAccessibility.AsString()}partial interface {serviceProvider.InterfaceIdentifier.AsOpenName()}{disposeInterfaces} {{\n");
        core.indent.IncreaseLevel(); // 1

        // "special" method CreateScope()
        if (serviceProvider.GenerateScope) {
            core.AppendCreateScopeSummary();
            builder.AppendInterpolation($"{core.indent}global::{serviceProvider.InterfaceIdentifierScope.AsOpenFullyQualified()} CreateScope{serviceProvider.IdentifierScope.AsOpenGenerics()}(");
            foreach (Dependency dependency in serviceProvider.CreateScope.ConstructorDependencyList.Concat<Dependency>(serviceProvider.CreateScope.PropertyDependencyList))
                if (!dependency.HasAttribute)
                    builder.AppendInterpolation($"global::{dependency.ServiceType.AsClosedFullyQualified()} {dependency.Name}, ");
            if (builder[^1] == ' ')
                builder.Length -= 2;
            builder.Append(");\n\n");
        }

        // service getter
        foreach (Service service in serviceProvider.SortedServiceList) {
            if (service.Lifetime.HasFlag(ServiceLifetime.Scoped))
                continue;
            if (service.Implementation.Type != MemberType.None && service.Implementation.IsScoped)
                continue;

            core.AppendServiceSummary(service);

            bool hasRef = service.IsRefable && !serviceProvider.Keyword.HasFlag(TypeKeyword.Struct);
            if (service.GetAccessor == GetAccess.Property)
                builder.AppendInterpolation($"{core.indent}{(hasRef ? "ref " : "")}global::{service.ServiceType.AsClosedFullyQualified()} {service.Name} {{ get; }}\n\n");
            else
                builder.AppendInterpolation($"{core.indent}{(hasRef ? "ref " : "")}global::{service.ServiceType.AsClosedFullyQualified()} Get{service.Name}();\n\n");
        }

        // IScope
        if (serviceProvider.GenerateScope) {
            core.SetToScope();
            builder.Append('\n');

            // class head
            core.AppendClassSummary();
            string disposeInterfacesScope = serviceProvider.GenerateDisposeMethodsScope switch {
                DisposeGeneration.NoDisposing => string.Empty,
                DisposeGeneration.Dispose => " : IDisposable",
                DisposeGeneration.DisposeAsync => " : IAsyncDisposable",
                DisposeGeneration.GenerateBoth => " : IDisposable, IAsyncDisposable",
                _ => throw new Exception($"Invalid DisposeGenerationEnum value: serviceProvider.GenerateDisposeMethodsScope = {serviceProvider.GenerateDisposeMethodsScope}")
            };
            builder.AppendInterpolation($"{core.indent}{serviceProvider.InterfaceAccessibilityScope.AsString()}partial interface IScope{serviceProvider.InterfaceIdentifierScope.AsOpenGenerics()}{disposeInterfacesScope} {{\n");
            core.indent.IncreaseLevel(); // 2

            // service getter
            foreach (Service service in serviceProvider.SortedServiceList) {
                core.AppendServiceSummary(service);

                bool isSingletonNotRefable = service.Lifetime == ServiceLifetime.Singleton && serviceProvider.Keyword.HasFlag(TypeKeyword.Struct);
                bool hasRef = service.IsRefable && !serviceProvider.KeywordScope.HasFlag(TypeKeyword.Struct) && !isSingletonNotRefable;
                if (service.GetAccessor == GetAccess.Property)
                    builder.AppendInterpolation($"{core.indent}{(hasRef ? "ref " : "")}global::{service.ServiceType.AsClosedFullyQualified()} {service.Name} {{ get; }}\n\n");
                else
                    builder.AppendInterpolation($"{core.indent}{(hasRef ? "ref " : "")}global::{service.ServiceType.AsClosedFullyQualified()} Get{service.Name}();\n\n");
            }

            builder.Length--;
            core.indent.DecreaseLevel(); // 1
            builder.AppendInterpolation($"{core.indent}}}\n");
        }
        else
            builder.Length--;

        core.indent.DecreaseLevel(); // 0
        builder.AppendInterpolation($"{core.indent}}}\n");

        // containing types closing
        for (int i = 0; i < serviceProvider.InterfaceIdentifier.ContainingTypeList.Count; i++) {
            core.indent.DecreaseLevel();
            builder.AppendInterpolation($"{core.indent}}}\n");
        }

        string source = builder.ToString();
        string hintName = builder.CreateHintName(serviceProvider.InterfaceIdentifier, ".g.cs");
        context.AddSource(hintName, source);

        stringBuilderPool.Return(builder);
    }
}
